---
import { getCollection, getEntry } from "astro:content";
import Header from "~/components/header.astro";
import Footer from "~/components/footer.astro";
import ContentSection from "~/components/content-section.astro";
import { Icon } from "astro-icon/components";
import ToolModal from "~/components/tools/ToolModal.astro";
import { Image } from "astro:assets";
import WriteupMeta from "~/components/writeups/WriteupMeta.astro";

import "~/styles/theme.css";
// Import auto-hyperlink functions properly
import autoHyperlinkUtils, { extractTagSuggestions } from "~/utils/auto-hyperlink";
import 'katex/dist/katex.min.css';

// Generate paths for all writeups
export async function getStaticPaths() {
  const writeupEntries = await getCollection("writeups");
  return writeupEntries.map((entry) => ({
    params: { slug: entry.slug },
    props: { entry },
  }));
}

// Get the entry for this page
const { entry } = Astro.props;
const { Content } = await entry.render();

// Format date
const formattedDate = new Intl.DateTimeFormat("en-US", {
  year: "numeric",
  month: "long",
  day: "numeric",
}).format(entry.data.pubDate);

// Generate suggested tags if none exist or fewer than 3
const existingTags = entry.data.tags || [];
let suggestedTags = [];

if (existingTags.length < 3) {
  // Extract suggested tags from content using the imported function
  suggestedTags = extractTagSuggestions(entry.body, existingTags).slice(
    0,
    5 - existingTags.length,
  );
}

// Rest of your code remains the same
// ...

// Try to get section data if available
let sectionData = null;
if (entry.data.section) {
  try {
    // Try to fetch section by slug (convert section name to slug format)
    const sectionSlug = entry.data.section.toLowerCase().replace(/\s+/g, '-');
    sectionData = await getEntry('sections', sectionSlug);
  } catch (e) {
    // Section doesn't exist in the collection - will be handled dynamically
    sectionData = null;
  }
}

// Get section info if available
const sectionName = entry.data.section || null;
const sectionTextIcon = sectionData?.data?.icon || null;
const sectionIconImage = sectionData?.data?.iconImage || null;
const sectionColor = sectionData?.data?.color || null; 
const sectionImage = sectionData?.data?.image || null;

// Determine which image to display - writeup image takes precedence
const displayImage = entry.data.image || sectionImage || null;

// Get related writeups (by category or tag)
const allWriteups = await getCollection("writeups");
const relatedWriteups = allWriteups
  .filter(
    (writeup) =>
      // Not the current writeup
      writeup.slug !== entry.slug &&
      // Not hidden
      !writeup.data.hidden &&
      // Same category or at least one matching tag
      ((entry.data.category && writeup.data.category === entry.data.category) ||
        (existingTags.length > 0 &&
          writeup.data.tags &&
          writeup.data.tags.some((tag) => existingTags.includes(tag)))),
  )
  .sort((a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf())
  .slice(0, 3); // Limit to 3 related writeups

  const difficultyTags = ["easy", "medium", "hard"];


// Get difficulty color and icon
function getDifficultyInfo(tag) {
  if (!tag) return null;
  
  const tagLower = tag.toLowerCase();
  
  switch(tagLower) {
    case 'easy':
      return {
        color: '#4ade80', // green
        bgColor: 'rgba(74, 222, 128, 0.2)',
        icon: 'mdi:shield-check-outline'
      };
    case 'medium':
      return {
        color: '#fb923c', // orange
        bgColor: 'rgba(251, 146, 60, 0.2)',
        icon: 'mdi:shield-alert-outline'
      };
    case 'hard':
      return {
        color: '#f87171', // red
        bgColor: 'rgba(248, 113, 113, 0.2)',
        icon: 'mdi:shield-alert'
      };
    default:
      return null;
  }
}

const difficultyTag = (entry.data.tags || []).find(tag => 
  difficultyTags.includes(tag.toLowerCase())
);

const difficultyInfo = getDifficultyInfo(difficultyTag);



---

<!doctype html>
<html lang="en" class="h-full motion-safe:scroll-smooth" data-theme="dark">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <meta content="#ec4899" data-react-helmet="true" name="theme-color" />
    <meta name="generator" content={Astro.generator} />
    <title>{entry.data.title} | sealldev</title>
    <meta name="description" content={entry.data.description} />

    <!-- social media -->
    <meta property="og:title" content={`${entry.data.title} | sealldev`} />
    <meta property="og:type" content="article" />
    <meta property="og:description" content={entry.data.description} />

    <!-- initialize theme -->
    <script is:inline>
      document.documentElement.dataset.theme = "dark";
    </script>

    <!-- Initialise Flowbite -->
    <script
      is:inline
      src="https://cdn.jsdelivr.net/npm/flowbite@2.5.2/dist/flowbite.min.js"
    ></script>
  </head>

  <body
    class="h-full overflow-x-hidden bg-default text-default text-base selection:bg-secondary selection:text-white"
  >
    <Header />

    <main>
      <article class="pb-32 pt-24">
        <div class="mx-auto max-w-4xl px-8">
          <div class="mb-8">
            <a
              href="/writeups"
              class="hover:text-primary/70 flex items-center gap-2 text-primary"
            >
              <Icon name="mdi:arrow-left" class="size-5" />
              Back to Writeups
            </a>
          </div>

          <header class="mb-8">
            <h1 class="text-text gradient-text mb-4 font-bold text-4xl">
              {entry.data.title}
            </h1>

            <div class="mb-4 flex flex-wrap gap-4">
              <time
                datetime={entry.data.pubDate.toISOString()}
                class="text-text-offset"
              >
                {formattedDate}
              </time>

              {
                entry.data.author && (
                  <div class="text-text-offset">
                    by <span class="text-primary">{entry.data.author}</span>
                  </div>
                )
              }
            </div>

            <div class="mb-3 flex flex-wrap gap-2">
              {/* Section with icon if available */}
              {
                sectionName && (
                  <span 
                    class="rounded-full px-3 py-1 font-medium text-white text-sm flex items-center"
                    style={sectionColor ? `background-color: ${sectionColor}` : 'background-color: var(--color-primary)'}>
                    
                    {/* Section icon - show image icon first, then fall back to text icon */}
                    {sectionIconImage ? (
                      <Image 
                        src={sectionIconImage} 
                        alt={`${sectionName} icon`}
                        width={16}
                        height={16}
                        class="mr-1.5"
                        loading="eager"
                      />
                    ) : sectionTextIcon ? (
                      <span class="mr-1.5">{sectionTextIcon}</span>
                    ) : null}
                    
                    {sectionName}
                  </span>
                )
              }

              {
                entry.data.ctf && (
                  <span class="bg-primary/20 rounded-full px-3 py-1 text-primary text-sm">
                    {entry.data.ctf}
                  </span>
                )
              }

              {
                entry.data.category && (
                  <span class="bg-secondary/20 rounded-full px-3 py-1 text-secondary text-sm">
                    {entry.data.category}
                  </span>
                )
              }
            </div>

            <!-- Display tags, filtering out difficulty tags for PicoCTF -->
            <div class="mb-3 flex flex-wrap gap-1">
              {
                (() => {
                  
                  // Filter out difficulty tags for PicoCTF section
                  const filteredTags = entry.data.section === "PicoCTF" 
                    ? existingTags.filter(tag => !difficultyTags.includes(tag.toLowerCase())) 
                    : existingTags;
                  
                  return filteredTags.map((tag) => (
                    <a
                      href={`/writeups?tag=${tag}`}
                      class="bg-background-alt hover:bg-primary/10 rounded-full px-2 py-0.5 text-primary transition-colors text-xs"
                    >
                      #{tag}
                    </a>
                  ));
                })()
              }
              {
              difficultyInfo && entry.data.section === "PicoCTF" && (
              <span 
                class="rounded-full px-2 py-1 text-xs font-medium flex items-center"
                style={`background-color: ${difficultyInfo.bgColor}; color: ${difficultyInfo.color};`}>
                <Icon name={difficultyInfo.icon} class="size-3 mr-1" />
                <span class="capitalize">{difficultyTag}</span>
              </span>
            )}

              {/* Suggested tags with different styling */}
              {
                suggestedTags.length > 0 && (
                  <div class="ml-2 flex items-center gap-1">
                    <span class="text-text-offset text-xs">Suggested:</span>
                    {suggestedTags.map((tag) => (
                      <span class="border-primary/30 text-text-offset rounded-full border border-dashed px-2 py-0.5 text-xs">
                        #{tag}
                      </span>
                    ))}
                  </div>
                )
              }
            </div>
          </header>

          {/* Featured image with gradient background styling similar to WriteupCard */}
          {displayImage ? (
            <div class="relative h-64 w-full rounded-lg mb-8 overflow-hidden">
              {/* Gradient background */}
              <div class="absolute inset-0 bg-gradient-to-r from-primary to-secondary"></div>
              
              {/* Title overlay (top-left when image is present) */}
              <div class="absolute top-4 left-4 w-3/5 text-white z-10">
                <span class="font-bold text-xl break-words">
                  {`${entry.data.title}${entry.data.ctf ? " / " + entry.data.ctf : ""}` ||
                    entry.data.ctf ||
                    "CTF Writeup"}
                </span>
              </div>
              
              {/* Image - positioned like in WriteupCard */}
              <div class="absolute right-4 top-1/2 -translate-y-1/2 overflow-hidden rounded-lg border-2 border-white/50 shadow-lg h-48 w-48">
                <Image
                  src={displayImage}
                  alt={entry.data.title}
                  class="h-full w-full object-cover"
                  width={500}
                  height={500}
                  loading="eager"
                />
              </div>
            </div>
          ) : (
            <div class="relative h-64 w-full rounded-lg mb-8 overflow-hidden">
              {/* Gradient background with centered text when no image */}
              <div class="absolute inset-0 bg-gradient-to-r from-primary to-secondary flex items-center justify-center text-center p-4">
                <span class="font-bold text-xl break-words text-white">
                  {`${entry.data.title}${entry.data.ctf ? " / " + entry.data.ctf : ""}` ||
                    entry.data.ctf ||
                    "CTF Writeup"}
                </span>
              </div>
            </div>
          )}
          <WriteupMeta entry={entry} />

          <!-- Table of Contents (Desktop only) -->
          <nav id="table-of-contents" class="hidden xl:block fixed left-8 top-24 w-56 max-h-[60vh] overflow-y-auto z-40">
            <ul id="toc-list" class="space-y-0.5">
              <!-- TOC items will be generated dynamically -->
            </ul>
          </nav>

          <div
            class="prose prose-lg dark:prose-invert max-w-none"
            id="writeup-content"
          >
            <Content />
          </div>

          <!-- Related writeups by tags or category -->
          {
            relatedWriteups.length > 0 && (
              <div class="border-border mt-16 border-t pt-8">
                <h2 class="mb-4 font-bold text-2xl">Related Writeups</h2>
                <div class="grid grid-cols-1 gap-4 md:grid-cols-2">
                  {relatedWriteups.map((writeup) => (
                    <a
                      href={`/writeups/${writeup.slug}`}
                      class="border-border hover:bg-background-offset block rounded-lg border p-4 transition-all hover:border-primary"
                    >
                      <h3 class="mb-1 font-bold text-lg">
                        {writeup.data.title}
                      </h3>
                      <p class="text-text-offset mb-2 text-sm">
                        {writeup.data.description.slice(0, 120)}
                        {writeup.data.description.length > 120 ? "..." : ""}
                      </p>
                      <div class="flex flex-wrap gap-2">
                        {writeup.data.tags &&
                          writeup.data.tags.map((tag) => (
                            <span class="bg-background-alt rounded-full px-2 py-0.5 text-primary text-xs">
                              #{tag}
                            </span>
                          ))}
                      </div>
                    </a>
                  ))}
                </div>
              </div>
            )
          }

          {/* Share and contribution section */}
          <div class="border-border mt-12 border-t pt-8">
            <div
              class="flex flex-col items-start justify-between gap-6 sm:flex-row"
            >
              <div>
                <h3 class="mb-2 font-bold text-lg">Share this writeup</h3>
                <div class="flex gap-2">
                  <a
                    href={`https://twitter.com/intent/tweet?text=${encodeURIComponent(entry.data.title)}&url=${encodeURIComponent(`https://seall.dev/writeups/${entry.slug}`)}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    class="bg-background-offset hover:bg-background-alt rounded-full p-2 transition-colors"
                    aria-label="Share on Twitter"
                  >
                    <Icon name="mdi:twitter" class="text-text-offset size-5" />
                  </a>
                  <a
                    href={`https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(`https://seall.dev/writeups/${entry.slug}`)}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    class="bg-background-offset hover:bg-background-alt rounded-full p-2 transition-colors"
                    aria-label="Share on LinkedIn"
                  >
                    <Icon name="mdi:linkedin" class="text-text-offset size-5" />
                  </a>
                  <button
                    id="copy-link-btn"
                    class="bg-background-offset hover:bg-background-alt rounded-full p-2 transition-colors"
                    aria-label="Copy link"
                  >
                    <Icon
                      name="mdi:link-variant"
                      class="text-text-offset size-5"
                    />
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>
    </main>

    <Footer />
    <ToolModal/>

    <!-- Image Zoom Modal -->
    <div id="image-zoom-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/80 backdrop-blur-sm">
      <div class="relative h-full w-full flex items-center justify-center p-4">
        <img id="zoomed-image" src="" alt="" class="max-h-full max-w-full object-contain cursor-zoom-in" />
        <button id="close-zoom-modal" class="absolute top-4 right-4 flex h-10 w-10 items-center justify-center rounded-full bg-black/50 text-white hover:bg-black/70 transition-colors z-10">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
    </div>

    <script>
      // Ensure the header always has the fixed-header class
      const header = document.getElementById("page-header");
      if (header) {
        header.classList.add("fixed-header");
      }

      // Table of Contents functionality
      function generateTableOfContents() {
        const contentDiv = document.getElementById("writeup-content");
        const tocList = document.getElementById("toc-list");
        const tocNav = document.getElementById("table-of-contents");
        
        if (!contentDiv || !tocList) return;

        // Find all headers in the content
        const headers = contentDiv.querySelectorAll("h1, h2, h3, h4, h5, h6");
        
        if (headers.length === 0) {
          // Hide TOC if no headers found
          tocNav.classList.add("hidden");
          return;
        }

        // Clear existing TOC content
        tocList.innerHTML = "";

        // Build hierarchical structure
        const headerStructure = [];
        let currentActiveSection = null;

        // Generate IDs and build structure
        headers.forEach((header, index) => {
          const headerText = header.textContent.trim();
          const headerId = `header-${index}`;
          const level = parseInt(header.tagName.substring(1));
          
          // Add ID to header for linking
          header.id = headerId;
          
          headerStructure.push({
            element: header,
            id: headerId,
            text: headerText,
            level: level,
            index: index
          });
        });

        // Find the highest level header used in the content
        const minHeaderLevel = Math.min(...headerStructure.map(h => h.level));

        // Function to build TOC based on current active section
        function buildTOC(activeHeaderId = null) {
          tocList.innerHTML = "";
          
          let activeHeaderInfo = null;
          
          // Find the active header
          if (activeHeaderId) {
            activeHeaderInfo = headerStructure.find(h => h.id === activeHeaderId);
          }
          
          // Find all ancestors of the active header
          const ancestorIndices = [];
          if (activeHeaderInfo) {
            let currentLevel = activeHeaderInfo.level;
            let currentIndex = activeHeaderInfo.index;
            
            // Go backwards to find all ancestors
            for (let i = currentIndex - 1; i >= 0; i--) {
              if (headerStructure[i].level < currentLevel) {
                ancestorIndices.unshift(i);
                currentLevel = headerStructure[i].level;
              }
            }
          }
          
          headerStructure.forEach((headerInfo, structIndex) => {
            const { id, text, level, index } = headerInfo;
            let shouldShow = false;
            
            if (level === minHeaderLevel) {
              // Always show top-level headers (whatever the highest level is)
              shouldShow = true;
            } else if (activeHeaderInfo) {
              // Show if this header is:
              // 1. An ancestor of the active header
              // 2. The active header itself
              // 3. A direct child of the active header or its ancestors
              
              if (ancestorIndices.includes(structIndex) || id === activeHeaderId) {
                // This is an ancestor or the active header
                shouldShow = true;
              } else {
                // Check if this is a direct child of active header or ancestors
                const parentIndex = ancestorIndices.concat([activeHeaderInfo.index]).find(ancestorIndex => {
                  const ancestor = headerStructure[ancestorIndex];
                  return ancestor.level === level - 1 && 
                         structIndex > ancestorIndex && 
                         !headerStructure.slice(ancestorIndex + 1, structIndex).some(h => h.level <= ancestor.level);
                });
                
                if (parentIndex !== undefined) {
                  shouldShow = true;
                }
              }
            }
            
            if (shouldShow) {
              // Calculate proper indentation relative to the minimum header level
              const indentClass = `ml-${Math.max(0, (level - minHeaderLevel) * 3)}`;
              
              // Create TOC list item
              const listItem = document.createElement("li");
              listItem.className = `${indentClass} transition-all duration-200`;
              listItem.setAttribute("data-toc-item", id);
              
              const link = document.createElement("a");
              link.href = `#${id}`;
              link.textContent = text;
              link.className = "block py-0.5 text-xs text-gray-400 hover:text-primary transition-colors duration-200 border-l-2 border-transparent hover:border-primary pl-2";
              link.setAttribute("data-toc-link", id);
              
              // Smooth scroll behavior
              link.addEventListener("click", (e) => {
                e.preventDefault();
                headerInfo.element.scrollIntoView({ 
                  behavior: "smooth",
                  block: "start",
                  inline: "nearest"
                });
                
                // Update URL without scrolling
                history.replaceState(null, null, `#${id}`);
              });
              
              listItem.appendChild(link);
              tocList.appendChild(listItem);
            }
          });
          
          // Highlight the active link after building
          if (activeHeaderId) {
            setTimeout(() => {
              const activeLink = document.querySelector(`[data-toc-link="${activeHeaderId}"]`);
              if (activeLink) {
                // Remove active class from all links
                document.querySelectorAll("[data-toc-link]").forEach(link => {
                  link.classList.remove("text-primary", "border-primary", "font-bold");
                  link.classList.add("text-gray-400", "border-transparent", "font-normal");
                });
                
                // Add active class to current link
                activeLink.classList.remove("text-gray-400", "border-transparent", "font-normal");
                activeLink.classList.add("text-primary", "border-primary", "font-bold");
              }
            }, 10);
          }
        }

        // Initial build
        buildTOC();

        // Set up intersection observer for active section highlighting
        const observerOptions = {
          rootMargin: "-100px 0px -50% 0px",
          threshold: 0
        };

        let currentActiveId = null;

        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            const id = entry.target.id;
            
            if (entry.isIntersecting && id !== currentActiveId) {
              currentActiveId = id;
              
              // Rebuild TOC with new active section (highlighting is handled inside buildTOC)
              buildTOC(id);
            }
          });
        }, observerOptions);

        // Start observing all headers
        headerStructure.forEach((headerInfo) => {
          observer.observe(headerInfo.element);
        });

        // Position TOC to avoid footer
        const positionTOC = () => {
          const footer = document.querySelector("footer");
          const article = document.querySelector("article");
          
          if (footer && article && tocNav) {
            const footerRect = footer.getBoundingClientRect();
            const articleRect = article.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            
            // Check if footer is visible in viewport
            if (footerRect.top < viewportHeight) {
              // Footer is visible, adjust TOC position
              const availableSpace = footerRect.top - 100; // 100px margin from footer
              tocNav.style.maxHeight = `${Math.max(300, availableSpace)}px`;
              tocNav.style.top = "100px"; // Fixed distance from top instead of center
              tocNav.style.transform = "translateY(0)";
            } else {
              // Footer not visible, use fixed top position like blog
              // tocNav.style.maxHeight = "60vh";
              // tocNav.style.top = "6rem"; // top-24 equivalent
              // tocNav.style.transform = "translateY(0)";
            }
          }
        };

        // Initial positioning
        positionTOC();
        
        // Update position on scroll and resize
        window.addEventListener("scroll", positionTOC);
        window.addEventListener("resize", positionTOC);
      }

      // Initialize TOC when DOM is ready
      document.addEventListener("DOMContentLoaded", () => {
        // Small delay to ensure content is fully rendered
        setTimeout(generateTableOfContents, 100);
        
        // Initialize image zoom functionality
        initializeImageZoom();
      });

      // Image zoom functionality
      function initializeImageZoom() {
        const modal = document.getElementById("image-zoom-modal");
        const zoomedImage = document.getElementById("zoomed-image");
        const closeButton = document.getElementById("close-zoom-modal");
        
        if (!modal || !zoomedImage || !closeButton) return;

        let isZoomed = false;
        let scale = 1;
        let translateX = 0;
        let translateY = 0;

        // Find all images in the writeup content
        const writeupContent = document.getElementById("writeup-content");
        if (!writeupContent) return;
        
        const images = writeupContent.querySelectorAll("img");
        
        images.forEach(img => {
          // Add zoom cursor and click handler (no hover zoom)
          img.style.cursor = "zoom-in";
          img.classList.add("writeup-zoomable-image");
          
          img.addEventListener("click", (e) => {
            e.preventDefault();
            openImageModal(img.src, img.alt);
          });
        });

        // Modal image zoom functionality
        zoomedImage.addEventListener("click", (e) => {
          const rect = zoomedImage.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const clickY = e.clientY - rect.top;
          
          if (!isZoomed) {
            // Zoom in at cursor position
            scale = 2;
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            translateX = (centerX - clickX) * scale;
            translateY = (centerY - clickY) * scale;
            isZoomed = true;
            zoomedImage.style.cursor = "zoom-out";
          } else {
            // Zoom out
            scale = 1;
            translateX = 0;
            translateY = 0;
            isZoomed = false;
            zoomedImage.style.cursor = "zoom-in";
          }
          
          updateImageTransform();
        });

        // Pan functionality when zoomed
        let isPanning = false;
        let startX, startY, initialTranslateX, initialTranslateY;

        zoomedImage.addEventListener("mousedown", (e) => {
          if (isZoomed && e.button === 0) {
            isPanning = true;
            startX = e.clientX;
            startY = e.clientY;
            initialTranslateX = translateX;
            initialTranslateY = translateY;
            zoomedImage.style.cursor = "grabbing";
            e.preventDefault();
          }
        });

        document.addEventListener("mousemove", (e) => {
          if (isPanning) {
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            translateX = initialTranslateX + deltaX;
            translateY = initialTranslateY + deltaY;
            updateImageTransform();
          }
        });

        document.addEventListener("mouseup", () => {
          if (isPanning) {
            isPanning = false;
            zoomedImage.style.cursor = isZoomed ? "zoom-out" : "zoom-in";
          }
        });

        function updateImageTransform() {
          zoomedImage.style.transform = `scale(${scale}) translate(${translateX / scale}px, ${translateY / scale}px)`;
          zoomedImage.style.transformOrigin = "center";
        }

        // Modal close handlers
        closeButton.addEventListener("click", closeImageModal);
        modal.addEventListener("click", (e) => {
          // Close if clicking on the modal background (not the image or its container)
          if (e.target === modal || (e.target.closest && !e.target.closest('#zoomed-image'))) {
            closeImageModal();
          }
        });

        // Close on escape key
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && !modal.classList.contains("hidden")) {
            closeImageModal();
          }
        });

        function openImageModal(src, alt) {
          zoomedImage.src = src;
          zoomedImage.alt = alt;
          modal.classList.remove("hidden");
          modal.classList.add("flex");
          document.body.style.overflow = "hidden";
          
          // Reset zoom state
          isZoomed = false;
          scale = 1;
          translateX = 0;
          translateY = 0;
          zoomedImage.style.cursor = "zoom-in";
          zoomedImage.style.transform = "scale(1) translate(0px, 0px)";
        }

        function closeImageModal() {
          modal.classList.add("hidden");
          modal.classList.remove("flex");
          document.body.style.overflow = "";
          zoomedImage.src = "";
          zoomedImage.alt = "";
          
          // Reset zoom state
          isZoomed = false;
          scale = 1;
          translateX = 0;
          translateY = 0;
        }
      }
    
      // Copy link button functionality
      const copyLinkBtn = document.getElementById("copy-link-btn");
      if (copyLinkBtn) {
        copyLinkBtn.addEventListener("click", () => {
          navigator.clipboard.writeText(window.location.href);
    
          // Show temporary tooltip
          const tooltip = document.createElement("span");
          tooltip.textContent = "Link copied!";
          tooltip.className =
            "absolute -top-8 left-1/2 transform -translate-x-1/2 px-2 py-1 bg-primary text-white text-xs rounded";
    
          copyLinkBtn.style.position = "relative";
          copyLinkBtn.appendChild(tooltip);
    
          setTimeout(() => {
            tooltip.remove();
          }, 2000);
        });
      }
    
      // Import the auto-hyperlink function
      import {
        processAutoHyperlinks,
        autoHyperlinkTerms,
        toolSlugMap
      } from "~/utils/auto-hyperlink";
    
      // Tool data cache to avoid multiple network requests
      const toolDataCache = {};
    
      // Function to load tool data from the tools JSON database
      async function loadToolData(toolSlug) {
        // If we have cached data, use it
        if (toolDataCache[toolSlug]) {
          return toolDataCache[toolSlug];
        }
    
        try {          
          // This assumes you have a global window.toolsData object with all tool data
          if (window.toolsData && window.toolsData[toolSlug]) {
            toolDataCache[toolSlug] = window.toolsData[toolSlug];
            return window.toolsData[toolSlug];
          }
          
          // Still no data, create a placeholder
          return {
            title: toolSlug.charAt(0).toUpperCase() + toolSlug.slice(1),
            description: `Information about ${toolSlug}`,
            categories: [],
            tags: [],
            platforms: []
          };
        } catch (error) {
          console.error(`Error loading tool data for ${toolSlug}:`, error);
          return null;
        }
      }
    
      // Function to open tool modal directly
      async function openToolModal(toolSlug) {
        // Find the tool modal element
        const modal = document.getElementById("tool-modal");
        if (!modal) {
          console.error("Tool modal element not found");
          return;
        }
        
        // Get tool data
        const toolData = await loadToolData(toolSlug);
        if (!toolData) {
          console.error(`Could not load data for tool: ${toolSlug}`);
          return;
        }
        
        // If there's a function to populate the modal already defined, use it
        if (typeof window.populateToolModal === 'function') {
          window.populateToolModal(toolData);
          
          // Use existing show modal function
          if (typeof window.showToolModal === 'function') {
            window.showToolModal();
          } else {
            // Fallback - manually show the modal
            modal.classList.remove("hidden");
            document.body.classList.add("overflow-hidden");
          }
          return;
        }
        
        // Otherwise, dispatch a custom event with the tool data
        // The tool modal component will listen for this event
        const event = new CustomEvent('opentoolmodal', {
          detail: { toolData }
        });
        document.dispatchEvent(event);
      }
    
      // Apply auto-hyperlinks to the content after it's rendered
      document.addEventListener("DOMContentLoaded", () => {
        // Process auto-hyperlinks in content
        const contentContainer = document.getElementById("writeup-content");
    
        if (contentContainer) {
          // Find all the text nodes that might contain our terms
          // We'll specifically target paragraphs, list items, headings, and blockquotes
          const textContainers = contentContainer.querySelectorAll(
            "p, li, h1, h2, h3, h4, h5, h6, blockquote",
          );
    
          textContainers.forEach((container) => {
            // Skip processing if this is a flag paragraph
            if (container.classList.contains("flag-paragraph")) {
              return;
            }
    
            // Process each term in our dictionary
            for (const [term, url] of Object.entries(autoHyperlinkTerms)) {
              // Function to replace term in HTML while preserving markup
              const replaceTermInHTML = (element) => {
                // Don't process if we're inside a link already
                if (element.tagName === "A" || element.closest("a")) return;
    
                // Don't process inside code or pre elements
                if (
                  element.tagName === "CODE" ||
                  element.tagName === "PRE" ||
                  element.closest("code") ||
                  element.closest("pre")
                )
                  return;
    
                // Process element's childNodes
                const childNodes = Array.from(element.childNodes);
    
                childNodes.forEach((node) => {
                  // If it's a text node, process it
                  if (node.nodeType === Node.TEXT_NODE) {
                    // Case insensitive match with 'i' flag
                    const regex = new RegExp(`\\b(${term})\\b`, "gi");
                    if (regex.test(node.textContent)) {
                      // Create wrapper for the new content
                      const wrapper = document.createElement("span");
    
                      // Check if this is a tool that should open the modal
                      if (url.startsWith("TOOL:")) {
                        const toolSlug = url.replace("TOOL:", "");
                        // Replace term with a span that will trigger the modal
                        const newHTML = node.textContent.replace(
                          regex,
                          (match) =>
                            `<span class="tool-modal-trigger cursor-pointer text-primary underline" data-tool-slug="${toolSlug}" title="Show details for ${term}">${match}</span>`,
                        );
                        wrapper.innerHTML = newHTML;
                      } else {
                        // Regular hyperlink
                        const newHTML = node.textContent.replace(
                          regex,
                          (match) =>
                            `<a href="${url}" class="auto-hyperlink" title="${term}">${match}</a>`,
                        );
                        wrapper.innerHTML = newHTML;
                      }
    
                      // Replace the text node with our processed content
                      const fragment = document.createDocumentFragment();
                      while (wrapper.firstChild) {
                        fragment.appendChild(wrapper.firstChild);
                      }
    
                      node.parentNode.replaceChild(fragment, node);
                    }
                  }
                  // If it's an element node, recurse (except for links, code, pre)
                  else if (node.nodeType === Node.ELEMENT_NODE) {
                    replaceTermInHTML(node);
                  }
                });
              };
    
              // Process this container
              replaceTermInHTML(container);
            }
          });
          
          // Add event listeners for tool modal triggers
          // Updated handler for tool modal triggers
const setupToolTriggers = () => {
  const toolTriggers = document.querySelectorAll('.tool-modal-trigger');
  
  toolTriggers.forEach(trigger => {
    if (!trigger.hasAttribute('data-listener-added')) {
      trigger.setAttribute('data-listener-added', 'true');
      
      trigger.addEventListener('click', function(e) {
        e.preventDefault();
        const toolSlug = this.getAttribute('data-tool-slug');
        
        if (toolSlug && window.openToolModal) {
          console.log(`Opening tool modal for: ${toolSlug}`);
          window.openToolModal(toolSlug);
        } else {
          console.error(`Could not open tool modal for ${toolSlug}. Modal function not available or no slug specified.`);
        }
      });
    }
  });
};

// Make sure this runs after page load and tool modal script has initialized
document.addEventListener('DOMContentLoaded', function() {
  // Wait a short time to ensure tool data is loaded
  setTimeout(() => {
    setupToolTriggers();
    
    // Also set up a mutation observer to catch dynamically added triggers
    const contentContainer = document.getElementById('writeup-content');
    if (contentContainer) {
      const observer = new MutationObserver(setupToolTriggers);
      observer.observe(contentContainer, { childList: true, subtree: true });
    }
    
    // Debug helper - log available tools
    if (window.toolsData) {
      console.log(`Tools available: ${window.toolsData.length}`);
      if (window.toolsData.length > 0) {
        // Log a few tool names as examples
        console.log(`Sample tools: ${window.toolsData.slice(0, 3).map(t => t.title).join(', ')}`);
      }
    } else {
      console.warn('No tools data available yet. Tool modals may not work correctly.');
    }
  }, 500);
});
          
          // Set up triggers initially
          setupToolTriggers();
          
          // Re-scan for triggers if content changes (for dynamic content)
          const observer = new MutationObserver(setupToolTriggers);
          observer.observe(contentContainer, { childList: true, subtree: true });
        }
    
        // Flag detection script
        const paragraphs = document.querySelectorAll(".prose p");
    
        paragraphs.forEach((paragraph) => {
          if (paragraph.textContent.includes("Flag:")) {
            paragraph.classList.add("flag-paragraph");
    
            // Find the code element inside the flag paragraph
            const codeElement = paragraph.querySelector("code");
            if (codeElement) {
              codeElement.classList.add("flag-code");
            }
          }
        });
      });
    </script>

    <script>
      window.addEventListener("DOMContentLoaded", async () => {

        const { default: renderMathInElement } = await import("katex/contrib/auto-render/auto-render.js");
        renderMathInElement(document.body, {
 
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "\\[", right: "\\]", display: true },
            { left: "$", right: "$", display: false },
            { left: "\\(", right: "\\)", display: false }
          ]
        });
      });

    </script>
    
    <style is:global>
      /* Improved code block styling */
      .prose pre {
        color: var(--color-text);
        padding: 1rem;
        border-radius: 0.5rem;
        overflow-x: auto;
        margin: 1.25rem 0; /* Reduce vertical spacing */
      }

      /* Reduce bottom padding specifically to fix code block closing tag spacing */
      .prose pre code {
        padding-bottom: 0.1rem;
      }

      @media (max-width: 768px) { /* For handling KaTeX rendering on slim screens (mobile) */
        .katex-display {
          font-size: clamp(0.25rem, 6vw, 0.7rem) !important;
        }
      }

      /* Inline code styling */
      .prose code:not(pre code) {
        background-color: var(--color-background-alt);
        color: var(--color-primary);
        padding: 0.2rem 0.4rem;
        border-radius: 0.25rem;
        font-size: 0.9em;
        font-weight: 500;
        white-space: pre-wrap;       /* Allow wrapping */
        word-wrap: break-word;       /* Break words when necessary */
        word-break: break-word;      /* More sophisticated word breaking */
        overflow-wrap: break-word;   /* Modern property for word wrapping */
        display: inline-block;       /* Change from inline to inline-block for better wrapping */
        max-width: 100%;             /* Ensure it doesn't exceed container width */
        box-decoration-break: clone; /* For consistent styling across line breaks */
      }

      /* Ensure paragraphs have proper spacing */
      .prose p {
        margin-bottom: 1.25rem;
        line-height: 1.6;
      }

      /* When there are consecutive paragraphs, ensure they have spacing */
      .prose p + p {
        margin-top: 1rem;
      }

      /* Fix blank lines in content */
      .prose br {
        display: block;
        content: "";
        margin-top: 1rem;
      }

      /* Improved header styling */
      .prose h1 {
        font-size: 2.25rem;
        margin-top: 2.5rem;
        margin-bottom: 1.5rem;
        font-weight: 700;
        color: var(--color-text);
        border-bottom: 2px solid var(--color-primary);
        padding-bottom: 0.5rem;
      }

      .prose h2 {
        font-size: 1.8rem;
        margin-top: 2rem;
        margin-bottom: 1rem;
        font-weight: 600;
        color: var(--color-text);
        border-bottom: 1px solid var(--color-border);
        padding-bottom: 0.5rem;
      }

      .prose h3 {
        font-size: 1.5rem;
        margin-top: 1.75rem;
        margin-bottom: 0.75rem;
        font-weight: 600;
        color: var(--color-text);
      }

      .prose h4 {
        font-size: 1.25rem;
        margin-top: 1.5rem;
        margin-bottom: 0.5rem;
        font-weight: 600;
        color: var(--color-text);
      }

      /* Ensure blockquotes are styled properly */
      .prose blockquote {
        border-left: 4px solid var(--color-primary);
        padding: 0.5rem 0 0.5rem 1rem;
        margin: 1.5rem 0;
        font-style: italic;
        color: var(--color-text-offset);
        background-color: var(--color-background-offset);
        border-radius: 0 0.25rem 0.25rem 0;
      }

      .prose blockquote p {
        margin-bottom: 0;
      }

      /* Improved link styling */
      .prose a {
        text-decoration: underline;
        text-decoration-color: var(--color-primary);
        text-decoration-thickness: 1px;
        text-underline-offset: 2px;
        transition:
          text-decoration-thickness 0.2s,
          text-underline-offset 0.2s;
      }

      .prose a:hover {
        text-decoration-thickness: 2px;
        text-underline-offset: 3px;
      }

      /* Auto-hyperlink styling */
      .prose a.auto-hyperlink {
        text-decoration-style: dotted;
        text-decoration-thickness: 1px;
        text-underline-offset: 3px;
      }

      .prose a.auto-hyperlink:hover {
        text-decoration-style: solid;
      }

      /* Special handling for blockquote links - make sure they're still visible */
      .prose blockquote a {
        color: var(--color-primary);
        text-decoration: underline;
        font-weight: 500;
      }

      /* Flag styling */
      .prose .flag-paragraph {
        position: relative;
        padding: 1rem 1.5rem;
        margin: 1.5rem 0;
        border-radius: 0.5rem;
        background-image: linear-gradient(
          to right,
          var(--color-background-offset),
          var(--color-background)
        );
        border-left: 4px solid var(--color-primary);
        font-weight: 500;
        overflow-wrap: break-word; /* Ensure text wraps */
        word-wrap: break-word; /* Legacy support */
        word-break: break-word; /* Allows breaking at appropriate points */
        hyphens: auto; /* Enables hyphenation */
      }

      .prose .flag-code {
        background-color: var(--color-background-alt);
        color: var(--color-secondary);
        position: relative;
        font-weight: 700;
        padding: 0.3rem 0.6rem;
        border-radius: 0.25rem;
        box-shadow: 0 0 10px rgba(236, 72, 153, 0.2);
        animation: flag-glow 2s ease-in-out infinite alternate;
        display: inline-block; /* Change from inline to inline-block */
        max-width: 100%; /* Ensure it doesn't exceed container width */
        overflow-wrap: break-word; /* Enable word wrapping */
        word-wrap: break-word; /* Legacy browsers */
        word-break: break-word; /* Break words only when necessary */
        white-space: pre-wrap; /* Preserve spaces but allow wrapping */
        box-decoration-break: clone; /* For wrapped text across lines */
        padding-left: 0.6rem; /* Maintain padding when wrapped */
        padding-right: 0.6rem;
      }

      /* Mobile-specific adjustments */
      @media (max-width: 640px) {
        .prose .flag-paragraph {
          padding: 0.75rem 1rem; /* Slightly reduce padding on mobile */
        }
        
        .prose .flag-code {
          font-size: 0.9em; /* Slightly smaller font on mobile */
          padding: 0.25rem 0.5rem; /* Reduce padding on mobile */
        }
      }

      @keyframes flag-glow {
        from {
          box-shadow: 0 0 5px rgba(236, 72, 153, 0.2);
        }
        to {
          box-shadow: 0 0 15px rgba(236, 72, 153, 0.5);
        }
      }

      /* Keep the gradient text styling for the page title only */
      .gradient-text {
        @apply bg-clip-text text-transparent;
        @apply bg-gradient-to-br from-pink-500 via-purple-500 to-indigo-500;
      }

      /* Unordered list styling */
      .prose ul {
        list-style-type: disc;
        margin-top: 1rem;
        margin-bottom: 1.5rem;
        padding-left: 1.5rem;
      }

      .prose ul li {
        margin-bottom: 0.5rem;
        position: relative;
      }

      /* Ordered list styling */
      .prose ol {
        list-style-type: decimal;
        margin-top: 1rem;
        margin-bottom: 1.5rem;
        padding-left: 1.5rem;
      }

      .prose ol li {
        margin-bottom: 0.5rem;
        position: relative;
      }

      /* Nested list styling */
      .prose ul ul,
      .prose ol ol,
      .prose ul ol,
      .prose ol ul {
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
      }

      /* Custom bullet color for light and dark themes */
      .prose ul li::marker {
        color: var(--color-primary);
      }

      .prose ol li::marker {
        color: var(--color-primary);
        font-weight: 500;
      }
      /* Meta information section styling with improved aesthetics */
.writeup-meta {
  background-color: rgba(var(--color-background-alt-rgb), 0.5);
  border-left: 4px solid var(--color-primary);
  padding: 1.5rem;
  margin-bottom: 2.5rem;
  border-radius: 0 0.5rem 0.5rem 0;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
}

.writeup-meta h2 {
  font-size: 1.25rem !important; 
  margin-top: 0 !important;
  margin-bottom: 1rem !important;
  border-bottom: none !important;
  padding-bottom: 0 !important;
  color: var(--color-primary) !important;
  font-weight: 600 !important;
}

.writeup-meta p {
  margin-bottom: 1rem !important;
  line-height: 1.6 !important;
  color: var(--color-text) !important;
}

.writeup-meta ul {
  margin-top: 0.75rem !important;
  margin-bottom: 0 !important;
  list-style-type: none !important;
  padding-left: 0 !important;
}

.writeup-meta li {
  margin-bottom: 0.5rem !important;
  display: flex !important;
  align-items: center !important;
  gap: 0.5rem !important;
}

.writeup-meta li::before {
  content: "•";
  color: var(--color-primary);
  font-weight: bold;
  display: inline-block;
  margin-right: 0.5rem;
}

.writeup-meta li strong {
  color: var(--color-primary);
  font-weight: 600;
  margin-right: 0.25rem;
}

/* Table of Contents Styling */
#table-of-contents {
  /* Ensure TOC doesn't interfere with page content on smaller screens */
  pointer-events: none;
}

#table-of-contents > ul {
  pointer-events: all;
}

/* TOC indentation levels */
#toc-list .ml-0 { margin-left: 0rem; }
#toc-list .ml-3 { margin-left: 0.75rem; }
#toc-list .ml-6 { margin-left: 1.5rem; }
#toc-list .ml-9 { margin-left: 2.25rem; }
#toc-list .ml-12 { margin-left: 3rem; }
#toc-list .ml-15 { margin-left: 3.75rem; }

/* TOC scrollbar styling */
#table-of-contents::-webkit-scrollbar {
  width: 4px;
}

#table-of-contents::-webkit-scrollbar-track {
  background: var(--color-background-alt);
  border-radius: 2px;
}

#table-of-contents::-webkit-scrollbar-thumb {
  background: var(--color-primary);
  border-radius: 2px;
}

#table-of-contents::-webkit-scrollbar-thumb:hover {
  background: var(--color-secondary);
}

/* Ensure TOC stays on screen on all sizes */
@media (min-width: 1280px) {
  #table-of-contents {
    left: 2rem; /* Simple fixed positioning */
  }
}

/* Hide TOC on smaller screens to avoid overcrowding */
@media (max-width: 1279px) {
  #table-of-contents {
    display: none !important;
  }
}

/* Image zoom functionality */
.writeup-zoomable-image {
  border-radius: 0.5rem;
  max-width: 100%;
  height: auto;
  transition: box-shadow 0.3s ease;
}

.writeup-zoomable-image:hover {
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
}

/* Image zoom modal */
#image-zoom-modal {
  backdrop-filter: blur(4px);
  animation: fadeIn 0.2s ease-out;
}

#image-zoom-modal.hidden {
  animation: fadeOut 0.2s ease-out;
}

#zoomed-image {
  animation: zoomIn 0.3s ease-out;
  border-radius: 0.5rem;
  box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
  transition: transform 0.3s ease;
  user-select: none;
  -webkit-user-drag: none;
}

/* Cursor states for modal image */
#zoomed-image.zoom-in {
  cursor: zoom-in;
}

#zoomed-image.zoom-out {
  cursor: zoom-out;
}

#zoomed-image.grabbing {
  cursor: grabbing;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

@keyframes zoomIn {
  from {
    transform: scale(0.8);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

/* Improve image styling in prose content */
.prose img {
  border-radius: 0.5rem;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  margin: 1.5rem auto;
  display: block;
}

/* Dark mode image adjustments */
[data-theme="dark"] .prose img {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}
    </style>
    <script>
      // Add this to your writeup [slug].astro file's <script> section
// This handles tool modal interactions in the writeup content

document.addEventListener("DOMContentLoaded", () => {
  // Process auto-hyperlinks in content
  const contentContainer = document.getElementById("writeup-content");

  if (contentContainer) {
    // Find all the text nodes that might contain our terms
    // We'll specifically target paragraphs, list items, headings, and blockquotes
    const textContainers = contentContainer.querySelectorAll(
      "p, li, h1, h2, h3, h4, h5, h6, blockquote",
    );

    textContainers.forEach((container) => {
      // Skip processing if this is a flag paragraph
      if (container.classList.contains("flag-paragraph")) {
        return;
      }

      // Process each term in our dictionary
      for (const [term, url] of Object.entries(autoHyperlinkTerms)) {
        // Function to replace term in HTML while preserving markup
        const replaceTermInHTML = (element) => {
          // Don't process if we're inside a link already
          if (element.tagName === "A" || element.closest("a")) return;

          // Don't process inside code or pre elements
          if (
            element.tagName === "CODE" ||
            element.tagName === "PRE" ||
            element.closest("code") ||
            element.closest("pre")
          )
            return;

          // Process element's childNodes
          const childNodes = Array.from(element.childNodes);

          childNodes.forEach((node) => {
            // If it's a text node, process it
            if (node.nodeType === Node.TEXT_NODE) {
              // Case insensitive match with 'i' flag
              const regex = new RegExp(`\\b(${term})\\b`, "gi");
              if (regex.test(node.textContent)) {
                // Create wrapper for the new content
                const wrapper = document.createElement("span");

                // Check if this is a tool that should open the modal
                if (url.startsWith("TOOL:")) {
                  const toolSlug = url.replace("TOOL:", "");
                  // Replace term with a span that will trigger the modal
                  const newHTML = node.textContent.replace(
                    regex,
                    (match) =>
                      `<span class="tool-modal-trigger cursor-pointer text-primary underline" data-tool-slug="${toolSlug}" title="Show details for ${term}">${match}</span>`,
                  );
                  wrapper.innerHTML = newHTML;
                } else {
                  // Regular hyperlink
                  const newHTML = node.textContent.replace(
                    regex,
                    (match) =>
                      `<a href="${url}" class="auto-hyperlink" title="${term}">${match}</a>`,
                  );
                  wrapper.innerHTML = newHTML;
                }

                // Replace the text node with our processed content
                const fragment = document.createDocumentFragment();
                while (wrapper.firstChild) {
                  fragment.appendChild(wrapper.firstChild);
                }

                node.parentNode.replaceChild(fragment, node);
              }
            }
            // If it's an element node, recurse (except for links, code, pre)
            else if (node.nodeType === Node.ELEMENT_NODE) {
              replaceTermInHTML(node);
            }
          });
        };

        // Process this container
        replaceTermInHTML(container);
      }
    });
    
    // Add event listeners for tool modal triggers
    const setupToolTriggers = () => {
      const toolTriggers = document.querySelectorAll('.tool-modal-trigger');
      
      toolTriggers.forEach(trigger => {
        if (!trigger.hasAttribute('data-listener-added')) {
          trigger.setAttribute('data-listener-added', 'true');
          
          trigger.addEventListener('click', function(e) {
            e.preventDefault();
            const toolSlug = this.getAttribute('data-tool-slug');
            
            if (toolSlug && window.openToolModal) {
              console.log(`Triggering modal for tool: ${toolSlug}`);
              window.openToolModal(toolSlug);
            } else {
              console.error(`Could not open tool modal for ${toolSlug}. Modal function not available.`);
            }
          });
        }
      });
    };
    
    // Set up triggers initially
    setupToolTriggers();
    
    // Re-scan for triggers if content changes (for dynamic content)
    const observer = new MutationObserver(setupToolTriggers);
    observer.observe(contentContainer, { childList: true, subtree: true });
  }

  // Flag detection script (keep your existing code)
  const paragraphs = document.querySelectorAll(".prose p");

  paragraphs.forEach((paragraph) => {
    if (paragraph.textContent.includes("Flag:")) {
      paragraph.classList.add("flag-paragraph");

      // Find the code element inside the flag paragraph
      const codeElement = paragraph.querySelector("code");
      if (codeElement) {
        codeElement.classList.add("flag-code");
      }
    }
  });
});

// Debug function to check if tool modals are working properly
function debugToolModals() {
  console.log("Checking tool modal functionality:");
  
  // Check if window.toolsData exists
  if (window.toolsData) {
    console.log(`✅ Tool data loaded: ${window.toolsData.length} tools available`);
    
    // Print first 3 tools as examples
    console.log("Sample tools:", window.toolsData.slice(0, 3));
  } else {
    console.error("❌ No tool data found! The ToolModal component may not have loaded correctly.");
  }
  
  // Check if the modal functions are available
  if (window.openToolModal && window.populateToolModal && window.showToolModal) {
    console.log("✅ Tool modal functions are properly exposed");
  } else {
    console.error("❌ Tool modal functions not found!");
    console.log("Available modal functions:", {
      openToolModal: !!window.openToolModal,
      populateToolModal: !!window.populateToolModal,
      showToolModal: !!window.showToolModal
    });
  }
  
  // Check tool triggers in content
  const triggers = document.querySelectorAll('.tool-modal-trigger');
  if (triggers.length > 0) {
    console.log(`✅ Found ${triggers.length} tool triggers in the content`);
    
    // List first 5 tools being referenced
    const toolSlugs = Array.from(triggers).slice(0, 5).map(t => t.getAttribute('data-tool-slug'));
    console.log("Referenced tools:", toolSlugs);
  } else {
    console.warn("⚠️ No tool triggers found in content. Either no tools are mentioned or auto-hyperlink processing failed.");
  }
  
  // Check modal element
  const modalElement = document.getElementById('tool-modal');
  if (modalElement) {
    console.log("✅ Tool modal element exists in the DOM");
  } else {
    console.error("❌ Tool modal element not found in the DOM!");
  }
  
  console.log("To test a tool modal, run: window.openToolModal('cyberchef')");
}

// Expose debug function globally
window.debugToolModals = debugToolModals;

// Run debug after 2 seconds to ensure everything is loaded
setTimeout(debugToolModals, 2000);
    </script>
  </body>
</html>